### 同步
两个进程同时运行，此时一个线程需要另一个线程提供的数据或者需要与另外一个线程进行数据同步，则该线程应该阻塞，等待另外一个线程发出同步完成的信号才能执行
### 互斥

同一时段， 只有一个进程可以获得资源(唯一)

### 信号量

使用信号量代表资源数目

```c
// Semaphore S;
// 原子性操作
wait(S){
  while(S<=0); // 资源不够， 进程阻塞
  
  S--;
}

signal(S){
  S++; // 释放一个资源
}
```

PV**原语**

wait操作记为**P操作**

signal操作记为**V操作**

**信号量实现同步**

```c
// 初始化信号量S = 0； 前V后P
int S=0；
  
p1() {
  //do something
  V(S);
}

p2(){
  P(S);
  //do something
}

// 这样p1，p2就会按照既定顺序 p1->p2 执行
```

**信号量实现互斥**

```c
// 初始化信号量 mutex = 1, 表示临界资源数量

p1() {
  P(mutex);  // 加锁
  // 访问临界资源
  V(mutex);  // 释放锁
}
```

### 死锁

<hr/>

**死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。** 

产生死锁需要满足下面四个条件：

1. **互斥条件**：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源。
2. **占有并等待条件**：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源。
3. **不可剥夺**：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放。
4. **循环等待条件**：进程发生死锁后，必然存在一个进程-资源之间的环形链。

