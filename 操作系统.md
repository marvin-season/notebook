### 同步

进程执行有次序，相互协作制约。**一个一个来**

### 互斥

同一时段， 只有一个进程可以获得资源(唯一)

### 信号量

使用信号量代表资源数目

```c
// Semaphore S;
// 原子性操作
wait(S){
  while(S<=0); // 资源不够， 进程阻塞
  
  S--;
}

signal(S){
  S++; // 释放一个资源
}
```

PV**原语**

wait操作记为**P操作**

signal操作记为**V操作**

**信号量实现同步**

```c
// 初始化信号量S = 0； 前V后P
int S=0；
  
p1() {
  //do something
  V(S);
}

p2(){
  P(S);
  //do something
}

// 这样p1，p2就会按照既定顺序 p1->p2 执行
```

**信号量实现互斥**

```c
// 初始化信号量 mutex = 1, 表示临界资源数量

p1() {
  P(mutex);  // 加锁
  // 访问临界资源
  V(mutex);  // 释放锁
}
```

### 死锁

<hr/>

**死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。** 

产生死锁需要满足下面四个条件：

1. **互斥条件**：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源。
2. **占有并等待条件**：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源。
3. **不可剥夺**：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放。
4. **循环等待条件**：进程发生死锁后，必然存在一个进程-资源之间的环形链。

